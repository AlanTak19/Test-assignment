"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8994],{78994:(e,r,t)=>{t.d(r,{Z:()=>g});var n=t(79995),a=t(130),u=t(84211),i=t(58604);let s=n.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(r=>{e.status="fulfilled",e.value=r},r=>{e.status="rejected",e.reason=r}),e}}),l={dedupe:!0};u.O.defineProperty(u.g,"defaultValue",{value:u.d});let o=(0,i.s6)((e,r,t)=>{let{cache:o,compare:c,suspense:d,fallbackData:g,revalidateOnMount:f,revalidateIfStale:E,refreshInterval:h,refreshWhenHidden:R,refreshWhenOffline:V,keepPreviousData:w}=t,[k,T,v,b]=u.b.get(o),[m,p]=(0,u.s)(e),C=(0,n.useRef)(!1),O=(0,n.useRef)(!1),_=(0,n.useRef)(m),L=(0,n.useRef)(r),S=(0,n.useRef)(t),y=()=>S.current,M=()=>y().isVisible()&&y().isOnline(),[N,U,D,I]=(0,u.z)(o,m),A=(0,n.useRef)({}).current,P=(0,u.e)(g)?(0,u.e)(t.fallback)?u.U:t.fallback[m]:g;P&&(0,u.B)(P)&&(P=s(P));let F=(e,r)=>{for(let t in A)if("data"===t){if(!c(e[t],r[t])&&(!(0,u.e)(e[t])||!c(H,r[t])))return!1}else if(r[t]!==e[t])return!1;return!0},j=(0,n.useMemo)(()=>{let e=!!m&&!!r&&((0,u.e)(f)?!y().isPaused()&&!d&&!1!==E:f),t=r=>{let t=(0,u.m)(r);return(delete t._k,e)?{isValidating:!0,isLoading:!0,...t}:t},n=N(),a=I(),i=t(n),s=n===a?i:t(a),l=i;return[()=>{let e=t(N());return F(e,l)?(l.data=e.data,l.isLoading=e.isLoading,l.isValidating=e.isValidating,l.error=e.error,l):(l=e,e)},()=>s]},[o,m]),x=(0,a.useSyncExternalStore)((0,n.useCallback)(e=>D(m,(r,t)=>{F(t,r)||e()}),[o,m]),j[0],j[1]),q=!C.current,z=k[m]&&k[m].length>0,B=x.data,Y=(0,u.e)(B)?P:B,Z=x.error,G=(0,n.useRef)(Y),H=w?(0,u.e)(B)?G.current:B:Y,J=(!z||!!(0,u.e)(Z))&&(q&&!(0,u.e)(f)?f:!y().isPaused()&&(d?!(0,u.e)(Y)&&E:(0,u.e)(Y)||E)),K=!!(m&&r&&q&&J),Q=(0,u.e)(x.isValidating)?K:x.isValidating,W=(0,u.e)(x.isLoading)?K:x.isLoading,X=(0,n.useCallback)(async e=>{let r,n;let a=L.current;if(!m||!a||O.current||y().isPaused())return!1;let i=!0,s=e||{},l=!v[m]||!s.dedupe,o=()=>u.I?!O.current&&m===_.current&&C.current:m===_.current,d={isValidating:!1,isLoading:!1},g=()=>{U(d)},f=()=>{let e=v[m];e&&e[1]===n&&delete v[m]},E={isValidating:!0};(0,u.e)(N().data)&&(E.isLoading=!0);try{if(l&&(U(E),t.loadingTimeout&&(0,u.e)(N().data)&&setTimeout(()=>{i&&o()&&y().onLoadingSlow(m,t)},t.loadingTimeout),v[m]=[a(p),(0,u.p)()]),[r,n]=v[m],r=await r,l&&setTimeout(f,t.dedupingInterval),!v[m]||v[m][1]!==n)return l&&o()&&y().onDiscarded(m),!1;d.error=u.U;let e=T[m];if(!(0,u.e)(e)&&(n<=e[0]||n<=e[1]||0===e[1]))return g(),l&&o()&&y().onDiscarded(m),!1;let s=N().data;d.data=c(s,r)?s:r,l&&o()&&y().onSuccess(r,m,t)}catch(t){f();let e=y(),{shouldRetryOnError:r}=e;!e.isPaused()&&(d.error=t,l&&o()&&(e.onError(t,m,e),(!0===r||(0,u.a)(r)&&r(t))&&(!y().revalidateOnFocus||!y().revalidateOnReconnect||M())&&e.onErrorRetry(t,m,e,e=>{let r=k[m];r&&r[0]&&r[0](u.h.ERROR_REVALIDATE_EVENT,e)},{retryCount:(s.retryCount||0)+1,dedupe:!0})))}return i=!1,g(),!0},[m,o]),$=(0,n.useCallback)((...e)=>(0,u.o)(o,_.current,...e),[]);if((0,u.v)(()=>{L.current=r,S.current=t,(0,u.e)(B)||(G.current=B)}),(0,u.v)(()=>{if(!m)return;let e=X.bind(u.U,l),r=0,t=(0,i.ko)(m,k,(t,n={})=>{if(t==u.h.FOCUS_EVENT){let t=Date.now();y().revalidateOnFocus&&t>r&&M()&&(r=t+y().focusThrottleInterval,e())}else if(t==u.h.RECONNECT_EVENT)y().revalidateOnReconnect&&M()&&e();else if(t==u.h.MUTATE_EVENT)return X();else if(t==u.h.ERROR_REVALIDATE_EVENT)return X(n)});return O.current=!1,_.current=m,C.current=!0,U({_k:p}),J&&((0,u.e)(Y)||u.t?e():(0,u.u)(e)),()=>{O.current=!0,t()}},[m]),(0,u.v)(()=>{let e;function r(){let r=(0,u.a)(h)?h(N().data):h;r&&-1!==e&&(e=setTimeout(t,r))}function t(){!N().error&&(R||y().isVisible())&&(V||y().isOnline())?X(l).then(r):r()}return r(),()=>{e&&(clearTimeout(e),e=-1)}},[h,R,V,m]),(0,n.useDebugValue)(H),d&&(0,u.e)(Y)&&m){if(!u.I&&u.t)throw Error("Fallback data is required when using Suspense in SSR.");L.current=r,S.current=t,O.current=!1;let e=b[m];if((0,u.e)(e)||s($(e)),(0,u.e)(Z)){let e=X(l);(0,u.e)(H)||(e.status="fulfilled",e.value=!0),s(e)}else throw Z}return{mutate:$,get data(){return A.data=!0,H},get error(){return A.error=!0,Z},get isValidating(){return A.isValidating=!0,Q},get isLoading(){return A.isLoading=!0,W}}}),c=u.I?e=>{e()}:n.startTransition,d=e=>{let[,r]=(0,n.useState)({}),t=(0,n.useRef)(!1),a=(0,n.useRef)(e),i=(0,n.useRef)({data:!1,error:!1,isValidating:!1}),s=(0,n.useCallback)(e=>{let n=!1,u=a.current;for(let r in e)u[r]!==e[r]&&(u[r]=e[r],i.current[r]&&(n=!0));n&&!t.current&&r({})},[]);return(0,u.v)(()=>(t.current=!1,()=>{t.current=!0})),[a,i.current,s]},g=(0,i.xD)(o,()=>(e,r,t={})=>{let{mutate:a}=(0,i.kY)(),s=(0,n.useRef)(e),l=(0,n.useRef)(r),o=(0,n.useRef)(t),g=(0,n.useRef)(0),[f,E,h]=d({data:u.U,error:u.U,isMutating:!1}),R=f.current,V=(0,n.useCallback)(async(e,r)=>{let[t,n]=(0,u.s)(s.current);if(!l.current)throw Error("Can’t trigger the mutation: missing fetcher.");if(!t)throw Error("Can’t trigger the mutation: missing key.");let i=(0,u.m)((0,u.m)({populateCache:!1,throwOnError:!0},o.current),r),d=(0,u.p)();g.current=d,h({isMutating:!0});try{let r=await a(t,l.current(n,{arg:e}),(0,u.m)(i,{throwOnError:!0}));return g.current<=d&&(c(()=>h({data:r,isMutating:!1,error:void 0})),null==i.onSuccess||i.onSuccess.call(i,r,t,i)),r}catch(e){if(g.current<=d&&(c(()=>h({error:e,isMutating:!1})),null==i.onError||i.onError.call(i,e,t,i),i.throwOnError))throw e}},[]),w=(0,n.useCallback)(()=>{g.current=(0,u.p)(),h({data:u.U,error:u.U,isMutating:!1})},[]);return(0,u.v)(()=>{s.current=e,l.current=r,o.current=t}),{trigger:V,reset:w,get data(){return E.data=!0,R.data},get error(){return E.error=!0,R.error},get isMutating(){return E.isMutating=!0,R.isMutating}}})}}]);